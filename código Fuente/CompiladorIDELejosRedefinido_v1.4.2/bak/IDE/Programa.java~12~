package IDE;

import java.io.*;
import javax.swing.text.BadLocationException;
import java.text.NumberFormat;
// para imprimir  VERIFICAR LOS CORRECTOS
import java.awt.*;
import java.text.*;
import javax.swing.*;
// fin de imports para imprimir
import java.awt.event.*;
import java.awt.Color;
import javax.swing.JOptionPane;
import javax.swing.event.*;
import javax.swing.undo.*;
import javax.swing.AbstractAction;
// Los siguientes imports son para la nueva clase derivada de JTextPane
import javax.swing.text.*;
import javax.swing.plaf.*;
import java.awt.event.*;


public class Programa extends javax.swing.JPanel {

  private String ruta;
  private String directorio;
  private String nombrePrograma;
  private boolean modificado;
  private Pantalla pantalla;
  private final UndoManager undo = new UndoManager();
  final NumberFormat nf = NumberFormat.getInstance();
  // variables para compilar el programa
  private Herramientas.Errores errores = new Herramientas.Errores();
  private Herramientas.Errores warnings = new Herramientas.Errores();

  // estructuras para implementar el color en PR y comentarios
  private javax.swing.text.StyledDocument doc;
  private javax.swing.text.Style style;
  private int inicaret, fincaret; // variables de inicio y fin de la posición de una PR o variable
  private int comentario; // si son comentarios: 0 = NO ES COMENTARIO, 1 = POSIBLE COMENTARIO, 2 = ES UN COMENTARIO
  private int lineaActual;
  private int columActual;
  private int posCaret;
  private boolean bandMenu;

  public Programa(Pantalla pant) {
    initComponents();
    ruta = "";
    directorio = "";
    nombrePrograma = "";
    modificado = false;
    pantalla = pant;
    inicaret = -1;
    fincaret = -1;
    comentario = 0;
    lineaActual = 1;
    columActual = 1;
    posCaret = 0;
    bandMenu = false;
    try {
      jbInit();
    }
    catch (Exception e) {
      e.printStackTrace();
    }
  }

  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  private void initComponents() { //GEN-BEGIN:initComponents
    scroll = new javax.swing.JScrollPane();
    codigo = new AGETextPane();
    rowCodigo = new JTextPane();
    setLayout(new java.awt.BorderLayout());

    codigo.getDocument().addUndoableEditListener(new UndoableEditListener() {
      public void undoableEditHappened(UndoableEditEvent evt) {
        undo.addEdit(evt.getEdit());
        validarDeshReh();
      }
    });

    codigo.getActionMap().put("Undo",
                              new AbstractAction("Undo") {
      public void actionPerformed(ActionEvent evt) {
        try {
          if (undo.canUndo()) {
            undo.undo();
            validarDeshReh();
          }
        }
        catch (CannotUndoException e) {
        }
      }
    });

    codigo.getActionMap().put("Redo",
                              new AbstractAction("Redo") {
      public void actionPerformed(ActionEvent evt) {
        try {
          if (undo.canRedo()) {
            undo.redo();
            validarDeshReh();
          }
        }
        catch (CannotRedoException e) {
        }
      }
    });

/// OJOJOJOJOJOJOJO        codigo.setTabSize(5);

    codigo.setFont(new java.awt.Font("Courier New", 0, 12));
    rowCodigo.setFont(new java.awt.Font("Courier New", 0, 12));
    codigo.addInputMethodListener(new java.awt.event.InputMethodListener() {
      public void inputMethodTextChanged(java.awt.event.InputMethodEvent evt) {
        codigoInputMethodTextChanged(evt);
      }

      public void caretPositionChanged(java.awt.event.InputMethodEvent evt) {
      }
    });

    scroll.setViewportView(codigo);
    scroll.setRowHeaderView(rowCodigo) ;

    add(scroll, java.awt.BorderLayout.CENTER);

  } //GEN-END:initComponent

  public void initPrograma() {
    codigo.setText("sociedad:\n\n\n\n\nfinSociedad\n\ncomportamiento:\n\n\n\n\nfinComportamiento\n\nacciones:\n\n\n\n\nfinAcciones");
    initColor();
//    setTabs(4);  // Coloca los tab's de 4 caracteres
  }

  public void setTabs( int charactersPerTab)
  {
  FontMetrics fm = codigo.getFontMetrics( codigo.getFont() );
  int charWidth = fm.charWidth( 'w' );
  int tabWidth = charWidth * charactersPerTab;

  TabStop[] tabs = new TabStop[30];

  for (int j = 0; j < tabs.length; j++)
  {
  int tab = j + 1;
  tabs[j] = new TabStop( tab * tabWidth );
  }

  TabSet tabSet = new TabSet(tabs);
  SimpleAttributeSet attributes = new SimpleAttributeSet();
  StyleConstants.setTabSet(attributes, tabSet);
  codigo.getStyledDocument().setParagraphAttributes(0, codigo.getDocument().getLength(), attributes, true);
  }

  public void setFocusCodigo(){
    codigo.requestFocus();
  }

  public void setCaretCodigo(int row){
    try{
      int i, j;
      for(i=0, j=1; j<row; i++){
        String cad = codigo.getText(i, 1);
        char caracter = cad.charAt(0);
        if (caracter == '\n') j++;
      }
      codigo.setCaretPosition(i);
    }catch (BadLocationException e) {}
  }

  private void validarDeshReh() {
    if (undo.canUndo()) {
      pantalla.validar(6);
    }
    else {
      pantalla.validar(7);
    }
    if (undo.canRedo()) {
      pantalla.validar(8);
    }
    else {
      pantalla.validar(9);
    }
  }

  private void codigoInputMethodTextChanged(java.awt.event.InputMethodEvent evt) { //GEN-FIRST:event_codigoInputMethodTextChanged
    setModificado(true);
    pantalla.validar(3);
  } //GEN-LAST:event_codigoInputMethodTextChanged

  public void setModificado(boolean valor) {
    modificado = valor;
  }

  public void abrir(String ruta) {
    try {
      BufferedReader fuente = new BufferedReader(
          new InputStreamReader(
          new FileInputStream(ruta)));
      //setRuta(ruta);
      this.ruta = ruta;
      codigo.read(fuente, null);
      fuente.close();
      initColor();
    }
    catch (IOException e) {} // IOException
  }

  private void setRuta(String ruta) {
    String e;
    int i = ruta.lastIndexOf('.');
    if (i > 0 && i < ruta.length()) {
      e = ruta.substring(i + 1, ruta.length());
      if (e.equals("age")) {
        this.ruta = ruta;
      }
    }
  }

  public void setDirectorio(String direc){
    directorio = direc + "\\";
  }

  public void setNombrePrograma(String nombre){
    nombrePrograma = nombre;
  }

  public String getNombrePrograma(){
    return nombrePrograma;
  }

  public void guardar(String ruta) {
    try {
      String extension = ruta.substring(ruta.length() - 4);
      if (extension.compareTo(".age")!=0) {
        ruta = ruta + ".age";
      }
      BufferedWriter destino = new BufferedWriter(
          new OutputStreamWriter(
          new FileOutputStream(ruta)));
      this.ruta = ruta;
      codigo.write(destino);
      destino.close();
      setModificado(false);
    }
    catch (IOException e) {}
  }

  public boolean getModificado() {
    return modificado;
  }

  public String getRuta() {
    return ruta;
  }

  public boolean existeRuta() {
    if (ruta != "") {
      return true;
    }
    return false;
  }

  public void pegar() {
    codigo.paste();
    setColor();
    update_codigo_renglon();
  }

  public void copiar() {
    codigo.copy();
  }

  public void cortar() {
    codigo.cut();
    setColor();
    update_codigo_renglon();
  }

  public void eliminar() {
    codigo.replaceSelection("");
  }

  public void deshacer() {
    if (undo.canUndo()) {
      undo.undo();
    }
    validarDeshReh();
  }

  public void rehacer() {
    if (undo.canRedo()) {
      undo.redo();
    }
    validarDeshReh();
  }

  public void seleccionarTodo() {
    codigo.selectAll();
    codigo.requestFocus();
    pantalla.validar(10);
  }

  public void imprimir() {
    /*      PrinterJob printJob = PrinterJob.getPrinterJob();
          Book book = new Book ();
          PageFormat pageFormat = new PageFormat();
          if(pageFormat ==null) pageFormat = printJob.defaultPage();
          book.append (codigo, pageFormat, book.getNumberOfPages() );
//      printJob.setPrintable(codigo, pageFormat);
          printJob.setPageable (book);*/
//    PrinterJob printJob = PrinterJob.getPrinterJob();
//    printJob.setPrintable(codigo);
//      printJob.setPageable((Pageable)codigo);
  /*  if (printJob.printDialog()) { //show print window
      try {
        printJob.print();
      }
      catch (PrinterException e) {}
    }*/
    /*
          //--- Create a new PrinterJob object
          PrinterJob printJob = PrinterJob.getPrinterJob ();
          //--- Create a new book to add pages to
          Book book = new Book ();
          //--- Add the cover page using the default page format for this print job
          book.append (new IntroPage (), printJob.defaultPage ());
          //--- Add the document page using a landscape page format
          PageFormat documentPageFormat = new PageFormat ();
          documentPageFormat.setOrientation (PageFormat.LANDSCAPE);
          book.append (new Document (), documentPageFormat);
          //--- Tell the printJob to use the book as the pageable object
          printJob.setPageable (book);

          if(printJob.printDialog()){
            try {
                  printJob.print();
            }
            catch (PrinterException ex) {
                 ex.printStackTrace();
            }
          }*/
  }

  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JScrollPane scroll;
  private AGETextPane codigo;
  private JTextPane rowCodigo;

  private void jbInit() throws Exception {
    codigo.addMouseListener(new java.awt.event.MouseAdapter() {
      public void mouseReleased(MouseEvent e) {
        codigo_mouseReleased(e);
      }
    });
    codigo.addFocusListener(new java.awt.event.FocusAdapter() {
      public void focusGained(FocusEvent e) {
        codigo_focusGained(e);
      }
    });
    rowCodigo.setBackground(new Color(245, 248, 250));
    rowCodigo.setEnabled(true);
    rowCodigo.setForeground(new Color(129, 172, 182));
    rowCodigo.setEditable(false);
    codigo.addCaretListener(new javax.swing.event.CaretListener() {
      public void caretUpdate(CaretEvent e) {
        codigo_caretUpdate(e);
      }
    });
//    codigo.addKeyListener(new JPrograma_codigo_keyAdapter(this));
/*    codigo.addMouseListener(new java.awt.event.MouseAdapter() {
      public void mouseClicked(MouseEvent e) {
        codigo_mouseClicked(e);
      }
    });
*/
    scroll.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
    scroll.setDebugGraphicsOptions(0);
    this.setForeground(Color.black);
    this.addFocusListener(new java.awt.event.FocusAdapter() {
      public void focusGained(FocusEvent e) {
        this_focusGained(e);
      }
    });
    codigo.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
      public void mouseDragged(MouseEvent e) {
        codigo_mouseDragged(e);
      }
    });
    codigo.addFocusListener(new java.awt.event.FocusAdapter() {
      public void focusGained(FocusEvent e) {
          codigo_focusGained(e);
      }
      public void focusLost(FocusEvent e) {
        codigo_focusLost(e);
      }
    });
    codigo.addKeyListener(new java.awt.event.KeyAdapter() {
/*      public void keyPressed(KeyEvent e) {
        codigo_keyPressed(e);
      }
*/
      public void keyTyped(KeyEvent e) {
        codigo_keyTyped(e);
      }

      public void keyReleased(KeyEvent e) {
        codigo_keyReleased(e);
      }
    });
  }

/*  void codigo_keyPressed(KeyEvent e) {
//  codigo.append("CARACTER : " + e.getKeyCode());
    switch (e.getKeyCode()) {
      case KeyEvent.VK_PASTE:
        JOptionPane.showMessageDialog(null, "ya salió - paste", "Alerta",
                                      JOptionPane.ERROR_MESSAGE);
        setModificado(true);
        break;
      case KeyEvent.VK_CUT:
        JOptionPane.showMessageDialog(null, "ya salió - cut", "Alerta",
                                      JOptionPane.ERROR_MESSAGE);
        setModificado(true);
        break;
      case KeyEvent.VK_ESCAPE:
        JOptionPane.showMessageDialog(null, "ya salió - escape", "Alerta",
                                      JOptionPane.ERROR_MESSAGE);
        break;
      case KeyEvent.VK_F1:
        JOptionPane.showMessageDialog(null, "ya salió - F1", "Alerta",
                                      JOptionPane.ERROR_MESSAGE);
        break;
      case KeyEvent.VK_UNDO:
        JOptionPane.showMessageDialog(null, "ya salió - UNDO", "Alerta",
                                      JOptionPane.ERROR_MESSAGE);
        deshacer();
        break;
      case KeyEvent.VK_RIGHT:
      case KeyEvent.VK_LEFT:
      case KeyEvent.VK_UP:
      case KeyEvent.VK_DOWN:
      case KeyEvent.VK_HOME:
      case KeyEvent.VK_END:
        if (e.isShiftDown()) {
          pantalla.validar(10); // habilitar
        }
        else {
          pantalla.validar(11); // deshabilitar
        }
        break;
      case KeyEvent.VK_CONTROL:
      case KeyEvent.VK_SHIFT:
        break;
      case KeyEvent.VK_V: // PEGAR  (CTRL + V)
        //setModificado(true);
        break;
      case KeyEvent.VK_X: // CORTAR (CTRL + X)
        if (e.isControlDown()) {
          pantalla.validar(11);
          pantalla.validar(12);
        } //setModificado(true);
        break;
      case KeyEvent.VK_C: // COPIAR (CTRL + C)
        if (e.isControlDown()) {
          pantalla.validar(12);
        }
        break;
      case 89: // REHACER  (CTRL + Y)

//                        if(xKey==17) rehacer();
        break;
      case 90: // DESHACER (CTRL + Z)

//                        if(xKey==17) deshacer();
        break;
      default:
        if (codigo.getSelectedText() != null) {
          pantalla.validar(10);
        }
        else {
          pantalla.validar(11);
        }
        break;
    }
//  setColor(e.getKeyChar());
  }
*/
  void codigo_focusGained(FocusEvent e) {
    if(pantalla.countProgramas()!=0){
      pantalla.validar(4); // si se ha modificado, habilitar la opción "guardar"
//      pantalla.validar(18);  //Carga los warnings/errorres del programa
      refreshStatusBar();
    }
  }

  void codigo_keyTyped(KeyEvent e) {
    bandMenu = true;
//    setModificado(true);
//    pantalla.validar(3);
  }

  void codigo_mouseDragged(MouseEvent e) {
    pantalla.validar(10);
  }

  public int ejecutar() {
    Herramientas.TablaSimbolos tabla_simbolos = new Herramientas.TablaSimbolos();
    errores = new Herramientas.Errores();
    warnings = new Herramientas.Errores();
    try {
      Lexico.AnalizadorLexico lexico = new Lexico.AnalizadorLexico(ruta, errores, tabla_simbolos); // constructor de la clase TLexico
      if (errores.vacio()) {
        Sintactico.Sociedad.ProgramaAge programa = new Sintactico.Sociedad.ProgramaAge(directorio, nombrePrograma, lexico, tabla_simbolos, errores, warnings);
        programa.analisis();
      }
      lexico = null;
      System.gc(); // llamada al recolector de basura
    }
    catch (ArrayIndexOutOfBoundsException e) { // Excepción : no se especifica el nombre del archivo fuente
      errores.insertar(0, "No especificó el nombre del archivo fuente");
    }
    tabla_simbolos = null;
    System.gc(); // llamada al recolector de basura
    return getCountErrores();
  }

  private void update_codigo_renglon(){
    // Actualiza los renglones ( cuando se han agregado/disminuído más de uno ).
    // Empieza desde cero y vuelve a desplegar la columna del número del renglón
    rowCodigo.setText("");
    long newLines = codigo.getDocument().getDefaultRootElement().getElementCount(); // counting old rows
    long lines = rowCodigo.getDocument().getDefaultRootElement().getElementCount(); // counting elemnts in LinePane
//      this.curLine = newLines;
      while(newLines > lines){
        String neu = rowCodigo.getText()+ lines + "\n";
        rowCodigo.setText("");
        rowCodigo.setText(neu);
        lines++;
      }
      String neu = rowCodigo.getText() + newLines;
      rowCodigo.setText("");
      rowCodigo.setText(neu);
    }

  private void initColor() {
    doc = codigo.getStyledDocument();
    // Es el color por default - Color Normal
    style = codigo.addStyle("0", null);
    javax.swing.text.StyleConstants.setForeground(style, Color.black);
    // Definición del Azul
    style = codigo.addStyle("1", null);
    javax.swing.text.StyleConstants.setForeground(style, new Color(0, 128, 255));
    javax.swing.text.StyleConstants.setBold(style, true);
    style = codigo.addStyle("2", null);
    javax.swing.text.StyleConstants.setForeground(style, new Color(115, 185, 255));
    javax.swing.text.StyleConstants.setBold(style, true);
    // Definición del Verde
    style = codigo.addStyle("3", null);
    javax.swing.text.StyleConstants.setForeground(style, new Color(0, 102, 0));
    javax.swing.text.StyleConstants.setBold(style, true);
    style = codigo.addStyle("4", null);
    javax.swing.text.StyleConstants.setForeground(style, new Color(0, 174, 0));
    javax.swing.text.StyleConstants.setBold(style, true);
    // Definición del Rojo
    style = codigo.addStyle("5", null);
    javax.swing.text.StyleConstants.setForeground(style, new Color(255, 0, 82));
    javax.swing.text.StyleConstants.setBold(style, true);
    style = codigo.addStyle("6", null);
    javax.swing.text.StyleConstants.setForeground(style, new Color(255, 111, 157));
    javax.swing.text.StyleConstants.setBold(style, true);
    // Estilo para comentarios -- Amarillo
    style = codigo.addStyle("7", null);
    javax.swing.text.StyleConstants.setForeground(style, new Color(192, 192, 192));
    setColor();
    update_codigo_renglon();
  }

 /* En esta función le da formato de color al programa
  * esto es en caso de pegar nuevo código
  * abrir un programa
  */
  private void setColor() {
      String temp;
      int ini = 0;
      int fin = 0;
      comentario = 0;
      boolean band = true;
      try {
// Verifica el contenido ya ordenado para verificarse hacia  ADELANTE
        fin = ini;
        do {
          String cad = codigo.getText(fin, 1);
          char caracter = cad.charAt(0);
          if (caracter == '/') {
            doc.setCharacterAttributes(fin, 1, codigo.getStyle("0"), true);
            comentario++;
            fin++;
            if (comentario == 2) {  // Si es un renglòn de comentarios
              inicaret = fin-2; // Una vez localizado los comentarios se posiciona
              inicoment(); // en el inicio de èste
              comentario = 0;
              ini= fincaret+1;
              fin = ini;
            }
          }
          else{
            if (Character.isLetter(caracter) || Character.isDigit(caracter) || caracter == '_') { // Es una posible PR
              if(comentario >0) ini++;
              comentario = 0;
              fin++;
              temp = "";
              temp = codigo.getText(ini, fin - ini);
              checkColorPR(temp, ini, temp.length());
            }
            else {
              doc.setCharacterAttributes(fin, 1, codigo.getStyle("0"), true);
              fin++;
              ini = fin;
              comentario = 0;
            }
          }
        }while (band); // ciclo para verificar todas los caracteres y construir PR
      }
      catch (BadLocationException e) {
        try {
          if (ini != fin) {
            temp = "";
            temp = codigo.getText(ini, fin - ini);
            checkColorPR(temp, ini, temp.length());
          }
        }
        catch (BadLocationException ee) {}
      }
    }

/*  Verifica la entrada continua de código, para darle formato de PR (color)
 *   o corregir cuando no es necesario el color
 */
  private void checkRowColor(int antRow, int adeRow) {
    String temp;
    int ini = 0;
    int fin = 0;
    int numRow = 0;
    int count = 0;
    comentario = 0;
    try {
      // Ubica los renglones antes para empezar a verificar
      if(antRow >0){
        ini= codigo.getCaretPosition() - 1;
        do {
          if(ini>=0){
            String cad = codigo.getText(ini, 1);
            char caracter = cad.charAt(0);
            if (caracter == '\n') {
              antRow--;
              count++;
            }
          }
          else{
            antRow = -1;
            count++;
          }
          ini--;
        }while (antRow + 1 > 0); // ciclo para verificar todas los caracteres y construir PR
        ini +=2;
      }
      else{
        ini = codigo.getCaretPosition();
      }
// Verifica el contenido ya ordenado para verificarse hacia  ADELANTE
      numRow = count + adeRow - 1; // -1 porque count tiene un '\n' de más
      fin = ini;
      do {
        String cad = codigo.getText(fin, 1);
        char caracter = cad.charAt(0);
        if (caracter == '/') {
          doc.setCharacterAttributes(fin, 1, codigo.getStyle("0"), true);
          comentario++;
          fin++;
          if (comentario == 2) {  // Si es un renglòn de comentarios
            inicaret = fin-2; // Una vez localizado los comentarios se posiciona
            inicoment(); // en el inicio de èste
            numRow--;
            comentario = 0;
            ini= fincaret+1;
            fin = ini;
          }
        }
        else{
          if (Character.isLetter(caracter) || Character.isDigit(caracter) ||
              caracter == '_') { // Es una posible PR
            if(comentario >0) ini++;
            comentario = 0;
            fin++;
            temp = "";
            temp = codigo.getText(ini, fin - ini);
            checkColorPR(temp, ini, temp.length());
          }
          else {
            if (caracter == '\n') {
              numRow--;
            }
            doc.setCharacterAttributes(fin, 1, codigo.getStyle("0"), true);
            fin++;
            ini = fin;
            comentario = 0;
          }
        }
      }while (numRow > 0); // ciclo para verificar todas los caracteres y construir PR
    }
    catch (BadLocationException e) {
      try {
        if (ini != fin) {
          temp = "";
          temp = codigo.getText(ini, fin - ini);
          checkColorPR(temp, ini, temp.length());
        }
      }
      catch (BadLocationException ee) {}
    }
    finally {
      inicaret = -1;
      fincaret = -1;
      comentario = 0;
    }
  }

  private void checkColorPR(String palabra, int inicio, int tam) {
    try {
      if (comentario < 2) {
        int numColor;
        numColor = pantalla.isPR(palabra);
        String str = String.valueOf(numColor);
        doc.setCharacterAttributes(inicio, tam, codigo.getStyle(str), true);
      }
      else {
        doc.setCharacterAttributes(inicio, tam, codigo.getStyle("7"), true);
      }

    }
    catch (NullPointerException e) {}
  }

  public int getCountWarning() {
    return warnings.getCountNodo();
  }

  public int getCountErrores() {
    return errores.getCountNodo();
  }

  public String getWarning(int renglon) {
    return warnings.getRowDesc(renglon);
  }

  public String getError(int renglon) {
    return errores.getRowDesc(renglon);
  }

  public int getRowWarning(int renglon) {
    return warnings.getRow(renglon);
  }

  public int getRowError(int renglon) {
    return errores.getRow(renglon);
  }

/*  void codigo_mouseClicked(MouseEvent e) {
    if (! (codigo.getCaretPosition() >= inicaret &
           codigo.getCaretPosition() <= fincaret)) {
      comentario = 0;
      inicaret = -1;
      fincaret = -1;
    }
  }
*/
  void inicoment() {
    try { // Las siguientes instrucciones cambian de color a comentarios
      boolean band = true;
      fincaret = inicaret + 2; // verifica si hay más caracteres dentro de los comentarios
      do {
        String cad = codigo.getText(fincaret, 1);
        char cartemp = cad.charAt(0);
        if (cartemp == '\n') { // si es el <enter>
          band = false; // se reduce fincaret para que permanezca igual el valor con la siguiente instrucción "fincaret++"
          fincaret--; // queda posicionado en el <enter>
        }
        fincaret++;
      } while (band);
      doc.setCharacterAttributes(inicaret, fincaret - inicaret, codigo.getStyle("7"), true);
      comentario++;
    }
    catch (BadLocationException ee) { // sucede esta excepción con el caso '/', termina el archivo
      doc.setCharacterAttributes(inicaret, fincaret - inicaret,
                                 codigo.getStyle("7"), true);
      comentario++;
    }
  }

  void codigo_keyReleased(KeyEvent e) {
  if(bandMenu){
    switch (e.getKeyCode()) {
      case KeyEvent.VK_PASTE:
        JOptionPane.showMessageDialog(null, "ya salió - paste", "Alerta",
                                      JOptionPane.ERROR_MESSAGE);
        setModificado(true);
        break;
      case KeyEvent.VK_CUT:
        JOptionPane.showMessageDialog(null, "ya salió - cut", "Alerta",
                                      JOptionPane.ERROR_MESSAGE);
        setModificado(true);
        break;
      case KeyEvent.VK_F1:
        JOptionPane.showMessageDialog(null, "ya salió - F1", "Alerta",
                                      JOptionPane.ERROR_MESSAGE);
        break;
      case KeyEvent.VK_UNDO:
        JOptionPane.showMessageDialog(null, "ya salió - UNDO", "Alerta",
                                      JOptionPane.ERROR_MESSAGE);
        deshacer();
        break;
      case KeyEvent.VK_RIGHT:
      case KeyEvent.VK_LEFT:
      case KeyEvent.VK_UP:
      case KeyEvent.VK_DOWN:
      case KeyEvent.VK_HOME:
      case KeyEvent.VK_END:
        if (e.isShiftDown()) { // Selecciona Texto (para copiar, cortar, pegar)
          pantalla.validar(10); // habilitar
        }
        else {
          pantalla.validar(11); // deshabilitar
        }
        break;
      case KeyEvent.VK_CONTROL:
      case KeyEvent.VK_SHIFT:
        break;
      case KeyEvent.VK_V: // PEGAR  (CTRL + V)
        setColor();
        update_codigo_renglon();
        setModificado(true);
        pantalla.validar(3); // Valida el guardar el archivo
        break;
      case KeyEvent.VK_X: // CORTAR (CTRL + X)
        if (e.isControlDown()) {
          pantalla.validar(11);
          pantalla.validar(12);
        }
        setColor();
        update_codigo_renglon();
        setModificado(true);
        pantalla.validar(3); // Valida el permitir guardar el archivo
        break;
      case KeyEvent.VK_C: // COPIAR (CTRL + C)
        if (e.isControlDown()) {
          pantalla.validar(12);
        }
        break;
      case 89: // REHACER  (CTRL + Y)

//                        if(xKey==17) rehacer();
        break;
      case 90: // DESHACER (CTRL + Z)

//                        if(xKey==17) deshacer();
        break;
      default:
        if (codigo.getSelectedText() != null) {
          pantalla.validar(10);
        }
        else {
          pantalla.validar(11);
        }
        checkRowColor(1, 1);
        setModificado(true);
        pantalla.validar(3); // Valida el permitir guardar el archivo
        break;
    }
  }
  bandMenu = false;
  if(e.getKeyCode() ==155)
    pantalla.setStatusBarInsert(!codigo.isOvertypeMode());
  }

  public void refreshStatusBar(){
      pantalla.setStatusBarLinea("Línea:" + nf.format(lineaActual) + " Columna:" + nf.format(columActual));
      pantalla.setStatusBarArchivo(nombrePrograma + ".age");
      pantalla.setStatusBarInsert(pantalla.isOverTypeMode());
//    Se maneja con el evento codigo_mouseReleased(MouseEvent e) {
//      codigo.setOvertypeMode(pantalla.isOverTypeMode());
  }

  private void updateRowCodigo(){
    /*
    Las siguientes instrucciones actualizan la columna de los renglones
     */
    long newLines = codigo.getDocument().getDefaultRootElement().getElementCount(); // counting old rows
    long lines = rowCodigo.getDocument().getDefaultRootElement().getElementCount(); // counting elemnts in LinePane
//    int curr = codigo.getDocument().getDefaultRootElement().getElementIndex( codigo.getCaretPosition() ); // add line only at the End of the document
//    if (curr != this.curLine) {
//      this.curLine = curr;
      if(newLines > lines) { // Condición que verifica cuando crece el documento
        String neu = rowCodigo.getText() + "\n" + newLines;
        rowCodigo.setText("");
        rowCodigo.setText(neu);
      }
      if(newLines < lines) { // Condición que verifica cuando disminuye el tamaño de los renglones del documento
        String neu = rowCodigo.getText();
        long count =0;
        int carF =0;
        count = lines - newLines;
        for(int i= neu.length(); i>0 && count>0 ; i--){
          if (neu.charAt(i-1) == '\n'){
            carF = i-1;
            count--;
          }
        }
        rowCodigo.setText("");
        rowCodigo.setText(neu.substring(0,carF));
      }
//    }
  }

  void codigo_caretUpdate(CaretEvent e) {
    updateRowCodigo(); // actualiza la columna de los renglones
    /*
     Las siguientes instrucciones colocan las coordenadas (renglon, columna) en las que
     se encuentra el programador.
     */
    posCaret = codigo.getCaretPosition();
    int currentLine = 1;
    int currentColumn = 1;
    try{
      Rectangle current = codigo.modelToView( posCaret );
      if (current == null)
        throw new BadLocationException("null Rectangle", posCaret);
      Rectangle one = codigo.modelToView(0);
      Rectangle two = codigo.modelToView(1);
      int width = two.x - one.x;
      if (width == 0)
        throw new BadLocationException("Empty document", 0);
      currentLine = ( (current.y - one.y) / current.height ) + 1;
      currentColumn = ( (current.x - one.x) / width ) + 1;
      lineaActual = currentLine;
      columActual = currentColumn;
    }
    catch(BadLocationException ble) {}
    catch(NullPointerException nulle) {}
    finally{
      pantalla.setStatusBarLinea("Línea:"+ nf.format( currentLine)+ " Columna:" +nf.format( currentColumn));
    }

  }

  public void this_focusGained(FocusEvent e) {
//    refreshStatusBar();
  }

  void codigo_focusLost(FocusEvent e) {
    bandMenu = false;
  }

/*
 *  El siguiente evento fuè llamado para que cree el cursor de acuerdo al
 *  OverTypeMode global que existe en JPantalla.
 *  Esto no se pudo hacer en el FocusGained ya que marca un error del NullPinter
 *  porque el cursor no està creado, aún no existe el componente.
*/
  void codigo_mouseReleased(MouseEvent e) {
      codigo.setOvertypeMode(pantalla.isOverTypeMode());
  }


}// FIN DE LA CLASE JPROGRAMA

/*class PrintableJTextPane
    extends JTextPane
    implements java.awt.print.Printable {

  private final static int POINTS_PER_INCH = 72;

  public int print(Graphics g, PageFormat pf, int pi) throws PrinterException {
//    if (pi >= 1)
//      return Printable.NO_SUCH_PAGE;
    //--- Create the Graphics2D object
    Graphics2D g2d = (Graphics2D) g;
    // Fuente de la impresión
//    g2d.setPaint (Color.black);
    String titleText = "Este es un programa de prueba";
    Font titleFont = new Font("helvetica", Font.BOLD, 10);
    g2d.setFont(titleFont);
    //--- Translate the origin to 0,0 for the top left corner
    g2d.translate(pf.getImageableX(), pf.getImageableY());
    g2d.drawString(titleText, POINTS_PER_INCH, POINTS_PER_INCH);
//    super.printAll(g2d);
//    super.paint(g2d);
    super.printAll(g2d);
    return Printable.PAGE_EXISTS;
  }

}

/*class JPrograma_codigo_keyAdapter extends java.awt.event.KeyAdapter {
  JPrograma adaptee;

  JPrograma_codigo_keyAdapter(JPrograma adaptee) {
    this.adaptee = adaptee;
  }
  public void keyReleased(KeyEvent e) {
    adaptee.codigo_keyReleased(e);
  }
  public void keyPressed(KeyEvent e) {
    adaptee.codigo_keyPressed(e);
  }
 }
 */

class AGETextPane extends JTextPane
{
        private static boolean isOvertypeMode;

        private Caret defaultCaret;
        private Caret overtypeCaret;

      // Constructor de la clase
        public AGETextPane(){
                setCaretColor( Color.black);
                defaultCaret = getCaret();
                overtypeCaret = new OvertypeCaret();
                overtypeCaret.setBlinkRate( defaultCaret.getBlinkRate() );
                setOvertypeMode( false );
        }

        /*
         Retorna el valor de OvertypeMode, es decir INSERT/OVERWRITE
         */
        public boolean isOvertypeMode()
        {
                return isOvertypeMode;
        }

        /*
         Coloca el cursor para uso dependiendo del modo (INSER/OVERWRITE (OVERTYPE))
         */
        public void setOvertypeMode(boolean isOvertypeMode)
        {
            this.isOvertypeMode = isOvertypeMode;
            int pos = getCaretPosition();

            if (isOvertypeMode()) setCaret(overtypeCaret);
            else setCaret(defaultCaret);
            setCaretPosition(pos);
        }

        /*
         Sobrecarga del método replaceSelection de la clase origen JComponent
         */
        public void replaceSelection(String text)
        {
          // Implementa el modo de sobreescritura mediante la selección del caracter
          // en el cual se tiene la posición actual
                if ( isOvertypeMode() ){
                  int pos = getCaretPosition();
                  if (getSelectedText() == null &&  pos < getDocument().getLength())
                    moveCaretPosition( pos + 1);
                }
                super.replaceSelection(text);
        }

        /*
         Sobrecarga del método processKeyEvent de JComponent
         */
        protected void processKeyEvent(KeyEvent e)
        {
          super.processKeyEvent(e);
          if (e.getID() == KeyEvent.KEY_RELEASED &&  e.getKeyCode() == KeyEvent.VK_INSERT)
            setOvertypeMode( ! isOvertypeMode() );
        }

        /* Las siguientes dos funciones nos ayuda a incluir la característica de NO WRAP sobre
         * un JTextPane.  Es decir, permite que se siga de largo en un renglón,
         * habilitando el scroll Horizontal
        */
        public void setSize(Dimension d){
          if (d.width < getParent().getSize().width)
            d.width = getParent().getSize().width;
          super.setSize(d);
        }

        public boolean getScrollableTracksViewportWidth(){
          return false;
        }

        /*
         Pinta una línea horizontal del ancho de una columna y 1 pixel de alto
         */
        class OvertypeCaret extends DefaultCaret
        {
          /*
           * El cursor de sobreescritura simplemente será una línea horizontal de 1 pixel de alto
           * (una vez esto se determinará dónde será pintada)
           */
                public void paint(Graphics g){
                 if (isVisible()){
                   try{
                     JTextComponent component = getComponent();
                     TextUI mapper = component.getUI();
                     Rectangle r = mapper.modelToView(component, getDot());
                     g.setColor(component.getCaretColor());
                     int width = g.getFontMetrics().charWidth( 'w' );
                     int y = r.y + r.height - 2;
                     g.drawLine(r.x, y, r.x + width - 2, y);
                   }
                   catch (BadLocationException e) {}
                 }
                }

                /*
                 *  Damage debe ser sobrecargado cuando el método paint es sobrecargado
                 *  (El área "damaged" es el área donde el cursor es pintado. Se debe
                 *  considerar el área para el cursor por default y este cursor)
                  */
                protected synchronized void damage(Rectangle r){
                  if (r != null){
                    JTextComponent component = getComponent();
                    x = r.x;
                    y = r.y;
                    width = component.getFontMetrics( component.getFont() ).charWidth( 'w' );
                    height = r.height;
                    repaint();
                  }
                }
        }// FIN DE LA CLASE OVERTYPECARET DERIVADA DE LA CLASE DEFAULTCARET
}// FIN DE LA CLASE DERIVADA DE JTEXTPANE


